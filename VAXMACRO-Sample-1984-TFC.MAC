;		Module Name	:	MH2QIO.MAR
;		Module Title	:	VAX/VMS MiniHub II- QIO
;		Version		:	01
;		Edit		:	01
;		Edit Date	:	21-Mar-1984
;

	.TITLE	MH2QIO
	.IDENT /01-01/

; +
; INTERFACE WITH CALLING (HIGHER-LEVEL) PROGRAMS
;
; 	Data is passed between MH2QIO and other programs by means of a 
;  	global program section called MH2MAP. This PSECT is declared in
;  	this program by a .PSECT directive and in its calling programs
;  	by a MAP. This PSECT is also contained in a separate shareable
;  	image for intertask (between handler and queue manager) data sharing.
;  	The following sections of the PSECT are read and written by MH2QIO:
;
; Parameters read by MH2QIO are:
;
;	1)  Internal Channel Number				MH2_ICHAN
;	2)  Send Buffer (Including Site and LDU numbers)	MH2_SBUF
;	3)  Send Buffer length					MH2_SLEN
;	4)  Number of leading syncs.				MH2_LSYNC
;	5)  Number of Trailing Syncs.				MH2_TSYNC
;	6)  Priority to assume during I/O operations. (>=16.)	MH2_PRIORITY
;	7)  Number of transmissions per write operation.	MH2_TRNCNT
;	8)  Number of retries					MH2_TRYCNT
;	9)  Time between writes in multiple write mode.		MH2_WTIME
;	10) Time between retries				MH2_RTIME
;	11) Maximum wait time for first response character.	MH2_FTIME
;	12) Maximum wait time between characters.		MH2_CTIME
;		NOTE: ALL PASSED TIME VALUES ARE IN TICS (1/60 SEC.)
;		FOR RSX VERSION COMPATABILITY. MH2QIO CONVERTS THESE
;		TO VAX-FORMAT TIME VALUES.
;	13) Operation mode flags				MH2_FLAGS
;
; Returned:
;
;	1) System Service Status (longword)			MH2_STATUSL
;	2) Receive Buffer (contains received message)		MH2_RBUF
;	3) Receive Buffer Length				MH2_RLEN
;	4) Communications Error Status (timeout, etc.)		MH2_STATUS2
;	5) Handler operation status (sending, receiving)     MH2_HANDLER_STATUS
; -
.PAGE
;***********************GLOBAL DATA***************************************


.PSECT	MH2MAP	PIC,OVR,REL,GBL,SHR,NOEXE,WRT,RD,LONG

MH2_ICHAN:	.BLKB	2		;INTERNAL CHANNEL NUMBER FOR QIO'S
MH2_DEV	:	.BLKB	4		;DEVICE NAME (NOT USED BY MH2QIO)
MH2_STATUSL:	.BLKB	4		;SYSTEM SERVICE STATUS
MH2_STATUS2:	.BLKB	2		;COMMUNICATION STATUS
MH2_FILLAREA:	.BLKB	8.		;AREA FOR LEADING SYNCS AND SYNCNOT
MH2_SBUF:				;START OF SEND BUFFER
SITE:		.BLKB	2		;FIRST TWO BYTES ARE SITE NUMBER
LDU:		.BLKB	1		;NEXT BYTE IS LDU NUMBER
COMMAND:	.BLKB	1		;NEXT BYTE IS COMMAND
		.BLKB	176.		;THE REST OF THE TRANSMIT BUFFER
MH2_SLEN:	.BLKB	2		;LENGTH OF SEND MESSAGE
MH2_LSYNC:	.BLKB	1		;NUMBER OF LEADING SYNCS
MH2_TSYNC:	.BLKB	1		;TRAILING SYNCS
MH2_RBUF:	.BLKB	260.		;RECEIVE BUFFER
MH2_RLEN:	.BLKB	2		;RECEIVE MESSAGE LENGTH
MH2_PRIORITY:	.BLKB	2		;REAL-TIME I/O PRIORITY
MH2_TRNCNT:	.BLKB	1		;TRANSMISSIONS PER WRITE
MH2_TRYCNT:	.BLKB	1		;NUMBER OF RETRIES
MH2_WTIME:	.BLKB	2		;TIME BETWEEN MULTIPLE WRITES
MH2_RTIME:	.BLKB	2		;TIME BETWEEN RETRIES
MH2_FTIME:	.BLKB	2		;MAX WAIT TIME FOR FIRST CHAR.
MH2_CTIME:	.BLKB	2		;MAX. TIME BETWEEN CHARS.
MH2_FLAGS:	.BLKB	1		;HANDLER MODE-SETTING FLAGS
		.BLKB	1		;FILL, FOR RSX ALIGNMENT.
MH2_HANDLER_STATUS:	.BLKB	2	;HANDLER OPERATIONAL STATUS FLAGS


.PAGE

.PSECT	DATA	PIC,CON,REL,LCL,NOSHR,NOEXE,RD,WRT,LONG
;****************LOCAL VARIABLES AND CONSTANT DEFINITIONS**********************

;-----------------------CONSTANTS---------------------------------------------
;;;;;	$SSDEF		;DEFINE ERROR CODES

SYNC = ^X18					; SYNC CHAR
SYNC2 = ^XE7					; SYNC NOT (ONES COMPLIMENT)
ONETICK = -10*1000*1000/60			;1/60TH SECOND DELTA TIME

TIMEFLAG = 10.					;EVENT FLAG SET BY TIMEOUTS
TIMEBIT = 1@<TIMEFLAG>				;BIT POSITION IN EVENTFLAG MASK
READFLAG = 11.					;EVENT FLAG SET BY READ QIO
READBIT = 1@<READFLAG>
;----------------------FLAG DEFINITIONS----------------------------------------

;		MH2_FLAGS SETTINGS
WRITEONLY = 1.					;FLAG FOR INDICATING WRITE ONLY
NORETRIES = 2.				;FLAG FOR NO RETRIES 
WRITEONCE = 4.					;WRITE ONCE PER BROADCAST
SHOWBUFF = 8.					;DISPLAY MESSAGES AT SYS$OUTPUT

;		MH2_STATUS2 SETTINGS
TIMEOUT = 1.
CRCBAD = 2.			;RETURNED TO CALLING FUNCTION ON CRC MISMATCH
GARBRCVD = 4.

;		READ FLAGS (RDSTAT)
SYNC1RCVD = 1.					;SYNC1 STATE (SYNC RECEIVED)
SYNC2RCVD = 2.					;SYNC2 STATE (NOTSYNC RECEIVED)
GETSIZ = 8.					;EXTRACT SIZE FROM MESSAGE
MSGDONE = 16.					;ENTIRE MESSAGE RECEIVED
;
;		HANDLER STATUS FLAGS (MH2_HANDLER_STATUS)
NOWSENDING = 4.
NOWREADING = 8.
LOGON = 64.
DEBUGON = 256.
;-----------------------LOCAL WORK AREA----------------------------------------


;		TIME-RELATED PARAMETERS

WTIME:		.LONG	0
		.LONG	-1
RTIME:		.LONG	0
		.LONG	-1
FTIME:		.LONG	0
CTIME:		.LONG	0

INT_TIME:	.LONG	0			;USED FOR SETIMR FUNCTIONS
		.LONG	-1

EV_FLAGS:	.LONG	0			;HOLDER FOR EVENT FLAGS $READEF
						;USED IN CHECKING FOR TIMEOUTS.

;		ENVIRONMENT SETUP AND CONTROL PARAMETERS

DISPFLAG:	.BYTE	0

CHANNEL:  	.WORD	0	;INTERNAL CHANNEL # OF MINIHUB TTY PORT

OLDPRI:		.WORD	0			; OLD PRIORITY
DEFPRI = 16.					; DEFAULT PRIORITY
PRIORITY:	.WORD	0			;PRIORITY TO USE FOR REALTIME

RETRYCOUNT:	.BLKB	1			;RETRY COUNT (DECREMENTED )
TRANSCOUNT:	.BLKB	1			;TRANSMIT COUNT 
TRANSACC:	.BLKB	1			;COPY OF TRANS COUNT (DECR)

;		PARAMETERS USED BY THE READ ROUTINE

TRMASK:		.BLKB	8			;TERMINAL RECEIVE MASK

BUFADDR:	.BLKB	4			; ADDRESS OF I/O BUFFER
BUFLEN:		.BLKW	1			; SIZE OF I/O BUFFER


IN_IOSB:	.BLKW	1			;IOSB FOR READS
IN_SIZE:	.BLKW	1			;BYTES RECEIVED
IN_DEVDEP:	.BLKB	4			;DEVICE DEPENDENT STAT

TEMPBUF:	.BLKB	1			;ONE-BYTE RECEIVE BUFFR

BYTESRCVD:	.BLKW	1			;BYTES RECEIVED
BYTESTOGO:	.BLKW	1			;BYTES REMAINING IN MESSAGE
OPCODE:		.BLKB	1			;FOR USE IN DERIVING RESP. SIZE

RDSTAT:		.BLKB	1			;READ STATUS



OFFSET:		.BLKB	4			;OFFSET INTO RECEIVE BUFFER



;		MESSAGE DISPLAY PARAMETERS (WILL BE REMOVED)



BLANKLINE:	.ASCID	/ /

SENT:
		.LONG	SENTSIZE
		.ADDRESS	SENTSTRING
SENTSTRING:
		.ASCII	/SEND:/
SENTSIZE = .-SENTSTRING

RCVD:
		.LONG	5
		.ADDRESS	RCVDSTRING
RCVDSTRING:
		.ASCII	/RECV: 18 18 E7/
RCVDSIZE = .-RCVDSTRING


BADVARANS:	.ASCID	/UNSUPPORTED VARIABLE RESPONSE/

GARBIN:		.ASCID	/GARBAGE RECEIVED!/

BADADDR:	.ASCID	/LDU ADDRESS MISMATCH/

CRCERR:		.ASCID	/CRC MISMATCH. RECEIVED: !XW  CALCULATED: !XW/


;		DATA NECESSARY FOR THE CRC COMMAND AND THE LIB$CRC ROUTINE


CRCDSC:		.LONG	50
		.ADDRESS	CRCBUF
CRCBUF:		.BLKW	50

.PSECT	CRCTABLE	PIC,OVR,REL,GBL,SHR,NOEXE,WRT,RD,LONG
	.BLKL	1
CRCTBL:	.BLKL	16				;TABLE FOR USE BY CRC COMMAND
.PAGE
;************************************************************************
;
;	   R E S P O N S E   L E N G T H   T A B L E
;
;************************************************************************
	.PSECT	MSGLENS	PIC,OVR,REL,GBL,SHR,NOEXE,WRT,RD,LONG
LENTBL:						;TABLE OF MESSAGE LENGTHS.
	.WORD	84		;INCLUDING MH2 OPCODES
	.WORD	3		;81
	.WORD	3		;82
	.WORD	37		;83
	.WORD	3		;84
	.WORD	3		;85
	.WORD	5		;86
	.WORD	37		;87
	.WORD	2		;88
	.WORD	2		;89
	.WORD	2		;8A
	.WORD	3		;8B
	.WORD	8		;8C
	.WORD	<-1>		;8D
	.WORD	9		;8E
	.WORD	3		;8F	(ET)
	.WORD	11		;90
	.WORD	3		;91
	.WORD	3		;92
	.WORD	3		;93
	.WORD	29		;94
	.WORD	29		;95
	.WORD	29		;96
	.WORD	2		;97
	.WORD	2		;98
	.WORD	3		;99
	.WORD	7		;9A
	.WORD	5		;9B	(DE)
	.WORD	3		;9C
	.WORD	2		;9D
	.WORD	7		;9E	(VE)
	.WORD	2		;9F	BUS SYNC
	.WORD	<-1>		;A0
	.WORD	2		;A1
	.WORD	3		;A2
	.WORD	3		;A3
	.WORD	12		;A4
	.WORD	2		;A5
	.WORD	3		;A6
	.WORD	3		;A7
	.WORD	3		;A8
	.WORD	3		;A9
	.WORD	3		;AA
	.WORD	5		;AB
	.WORD	4		;AC
	.WORD	4		;AD
	.WORD	2		;AE
	.WORD	5		;AF
	.WORD	29		;B0
	.WORD	5		;B1
	.WORD	<-1>		;B2
	.WORD	4		;B3
	.WORD	3		;B4
	.WORD	7		;B5
	.WORD	3		;B6
	.WORD	12		;B7	NEW MM COMMAND
	.WORD	0,0,0,0,0	;B8,B9,BA,BB,BC		UNUSED
	.WORD	0,0,0,0		;BD,BE,BF,C0		UNUSED
	.WORD	0,0,0,0		;C1,C2,C3,C4		MH2 ONE-WAYS
	.WORD	0,0,0,0		;C5,C6,C7,C8		MH2 ONE-WAYS
	.WORD	0,0,0,0,0	;C9,CA,CB,CC,CD		MH2 ONE-WAYS
	.WORD	3,20		;TL AND DG
	.WORD	0,0		;D0,D1			MH2 ONE-WAYS	
	.WORD	53,18		;CH AND MM
.PAGE
; +
; ***********************************************************************
;
;		P R O G R A M   S T A R T
;
; ***********************************************************************
; -


.PSECT MH2QIO	PIC,RD,NOWRT,EXE,LONG,SHR

		.ENTRY	MH2QIO,^M<R2,R3>
;------------------ RESET STATUS FLAGS AND SETUP DISPFLAG---------------------

		BICW2	#<NOWSENDING+NOWREADING>,G^MH2_HANDLER_STATUS	

		MOVB	#<-1.>,DISPFLAG
		BITB	#SHOWBUFF,G^MH2_FLAGS
		BNEQ	XIT
		BITW	#DEBUGON,G^MH2_HANDLER_STATUS
		BNEQ	XIT
		BITW	#LOGON,G^MH2_HANDLER_STATUS
		BNEQ	XIT
		CLRB	DISPFLAG
XIT:

;------------------ TIME CONSTANT CONVERSION-----------------------------------
;-----NOT NECESSARY ON RSX-11, WHERE TICKS ARE A NATURAL TIMER VALUE.----------

		MOVZWL	G^MH2_WTIME,R2		;PUT TICK COUNT INTO LONGWORD
		MULL3	R2,#ONETICK,WTIME	;CONVERT TO VAX TICKS
		MOVZWL	G^MH2_RTIME,R2		;PUT TICK COUNT INTO LONGWORD
		MULL3	R2,#ONETICK,RTIME	;CONVERT TO VAX TICKS
		MOVZWL	G^MH2_FTIME,R2		;PUT TICK COUNT INTO LONGWORD
		MULL3	R2,#ONETICK,FTIME	;CONVERT TO VAX TICKS
		MOVZWL	G^MH2_CTIME,R2		;PUT TICK COUNT INTO LONGWORD
		MULL3	R2,#ONETICK,CTIME	;CONVERT TO VAX TICKS

;----------------COPY RETRY COUNT AND WRITE COUNT TO LOCAL VARIABLES-----------

		MOVB	#1,RETRYCOUNT
		BITB	#NORETRIES,G^MH2_FLAGS
		BNEQ	10$
		MOVB	G^MH2_TRYCNT,RETRYCOUNT
10$:
		MOVB	#1,TRANSCOUNT
		BITB	#WRITEONCE,G^MH2_FLAGS
		BNEQ	11$
		MOVB	G^MH2_TRNCNT,TRANSCOUNT
11$:
		MOVW	G^MH2_PRIORITY,PRIORITY	
		BNEQ	5$			;DID USER SPECIFY PRIORITY?
		MOVW	#DEFPRI,PRIORITY	;IF NOT, USE DEFAULT PRIORITY

5$:
		MOVW	G^MH2_ICHAN,CHANNEL	;INTERNAL CHANNEL NUMBER

;******************BEGINNING OF ACTUAL COMMAND PROCESSING*********************
;-----------------------------------------------------------------------------
;             PART I- ADD LEADING AND TRAILING SYNCS AND CRC
;		(EXECUTED ONLY ONCE PER COMMAND)
;-----------------------------------------------------------------------------
WRITESETUP:
		MOVAB	G^MH2_SBUF,R2		;GET START OF MESSAGE
		MOVB	#SYNC2,-(R2)		;PREFACE WITH A SYNC-NOT
		MOVZBL	G^MH2_LSYNC,R3		;GET NUMBER OF LEADING SYNCS

1$:		MOVB	#SYNC,-(R2)		;ADD LEADING SYNC
		SOBGTR	R3,1$			;REPEAT FOR DESIRED NUMBER 

		MOVL	R2,BUFADDR		;SAVE START OF OVERALL MESSAGE
		MOVAB	G^MH2_SBUF,R2		;ADDRESS OF 1ST BYTE FOR CRC
		MOVZWL	G^MH2_SLEN,R3		;GET SIZE OF PASSED MESSAGE

		CRC	CRCTBL,#0,R3,G^MH2_SBUF	;CALCULATE CRC (IN R0 LOWER)
		ADDL	R3,R2			;FIND ADDRESS TO PUT CRC
		MOVW	R0,(R2)+		;PUT CRC IN MESSAGE BUFFER
		TSTB	G^MH2_TSYNC		;SEE IF TRAILING SYNCS 
		BLEQ	2$			;IF NONE, CONTINUE
		MOVZBL	G^MH2_TSYNC,R3		;GET # OF TRAILING SYNCS
3$:
		MOVB	#SYNC,(R2)+		;PUT THEM IN THE OUTPUT BUFR
		SOBGTR	R3,3$
2$:
		SUBL	BUFADDR,R2		;FIND TOTAL MESSAGE LENGTH
		MOVW	R2,BUFLEN		;SAVE MESSAGE LENGTH


.PAGE
;*****************************************************************************

		$SETSWM_S	SWPFLG=#1	;SET NOSWAP
		$SETPRI_S	PRI=G^MH2_PRIORITY,-
				PRVPRI=OLDPRI	;BUMP PRIORITY

SENDSEQ:					; GO HERE AT RETRY TIME
		BICW2	#NOWREADING,G^MH2_HANDLER_STATUS
		BISW2	#NOWSENDING,G^MH2_HANDLER_STATUS	;INDICATE WRITE

		$QIO_S		CHAN = G^MH2_ICHAN,-
				FUNC = #IO$_TTYREADALL!IO$M_PURGE,-
				P1 = TEMPBUF,-
				P2 = #1

		$CANCEL_S	CHAN = G^MH2_ICHAN	;CLEAR TYPEAHEAD BUFFER

		MOVB	TRANSCOUNT,TRANSACC	;MULTIPLE TRANSMIT COUNT


SHOWSENT:
		TSTB	DISPFLAG		;DISPLAY SENT MESSAGE?
		BEQL	ONEWRITE		;IF NOT, JUST SEND IT.
		CMPB	TRANSCOUNT,TRANSACC	;TEST FOR FIRST WRITE
		BNEQ	69$
		PUSHAQ	BLANKLINE
		CALLS	#1,PRINTIT
69$:
		PUSHL	#SENTSIZE		;PREFIX SIZE
		PUSHAB	SENTSTRING		;PREFIX ADDRESS
		MOVZWL	BUFLEN,R2		;BUFFER LENGTH
		PUSHL	R2			;PUSH STRING LENGTH
		PUSHL	BUFADDR			;PUSH STRING ADDRESS
		CALLS	#4,HEXOUT		;WRITE HEX STRING ON SCREEN

ONEWRITE:
		BITB	#WRITEONLY,G^MH2_FLAGS	;IS THIS WRITE-ONLY OPERATION?
		BNEQ	SENDMSG			;IF SO, GO TO WRITE ROUTINE.

99$:
		MOVL	FTIME,INT_TIME		;SET UP MESG. START WAIT TIMER
		BSBW	RDINIT			;INITIALIZE READ VARIABLES

		BSBW	READSETUP		;SET UP READ FUNCTION

SENDMSG:
		$CLREF_S	EFN = #1	;CLEAR EVENT FLAG 1 BEFORE QIO

		$QIOW_S	EFN = #1,-		; PERFORM PASSALL WRITE
			CHAN = CHANNEL,-
			FUNC = #IO$_WRITEVBLK!IO$M_NOFORMAT,-
			P1 = @BUFADDR,-
			P2 = BUFLEN

		BLBC	R0,76$
		DECB	TRANSACC		;IF GLOBAL, DECR. RETRY COUNT
		BEQL	76$			;IF LAST RETRY, EXIT
		$SETIMR_S	-
			EFN = #4,-
			DAYTIM = WTIME		;WAIT TWO SECONDS
		$WAITFR_S	EFN = #4
		BRW	SHOWSENT		;RESEND MESSAGE
76$:
		BITB	#WRITEONLY,G^MH2_FLAGS
		BEQL	STARTREAD
		BRW	EXIT
STARTREAD:
		BICW2	#NOWSENDING,G^MH2_HANDLER_STATUS
		BISW2	#NOWREADING,G^MH2_HANDLER_STATUS
77$:

		$WFLOR_S	EFN=#1,-	;WAIT FOR CHAR OR TIMEOUT
				MASK=#<TIMEBIT!READBIT>	
		
		$READEF_S	EFN=#1,-
				STATE=EV_FLAGS	;GET LOCAL EVENT FLAGS

		BITL	#TIMEBIT,EV_FLAGS	;CHECK FOR TIMEOUT
		BEQL	70$			;IF NOT, NORMAL PROCESSING.

		$CANCEL_S	CHAN=CHANNEL	;IF TIMEOUT, CANCEL IO.
		MOVW	#SS$_TIMEOUT,IN_IOSB	;SET ERROR IN CASE LAST RETRY

		JSB	SHOWRCVD		;IF SO, SHOW THEM
71$:
		BRW	RETRY
70$:
		BITB	#GARBRCVD,RDSTAT	;DID WE RECEIVE GARBAGE?
		BEQL	78$			;IF NO, CONTINUE
		MOVW	#GARBRCVD,G^MH2_STATUS2	;IF YES, INDICATE BAD DATA
		PUSHAQ	GARBIN
		CALLS	#1,PRINTIT
		JSB	SHOWRCVD		;SHOW ACTUAL MESSAGE
		BRW	RETRY			;AND EXIT
78$:
		BITB	#MSGDONE,RDSTAT		;IS THE WHOLE MESSAGE DONE?
		BNEQ	90$			;IF SO, PROCESS
		BSBW	READSETUP		;IF NOT, SET UP NEXT READ
		BRW	77$			;AND WAIT FOR IT TO FINISH
		
90$:		;CALCULATE CRC AND COMPARE
		BICW2	#NOWREADING,G^MH2_HANDLER_STATUS

		MOVZWL	BYTESRCVD,R3		;GET NUMBER OF BYTES
		SUBL	#2,R3			;EXCLUDE RECEIVED CRC
		MOVW	R3,G^MH2_RLEN		;INDICATE RECEIVED MESSAGE SIZE

		CRC	CRCTBL,#0,R3,G^MH2_RBUF	;CALCULATE CRC
		MOVZWL	(R3),R3			;GET  CRC (R3 SET BY CRC OP.)
		CMPL	R0,R3			;DO CRC'S MATCH?
		BEQL	NORMAL			;IF SO, NORMAL EXIT

		MOVW	#CRCBAD,G^MH2_STATUS2	;SET BAD CRC FLAG
		TSTB	DISPFLAG
		BEQL	100$
		$FAO_S	CTRSTR=CRCERR,-		;CONSTRUCT STATUS MESSAGE
			OUTLEN=CRCDSC,-
			OUTBUF=CRCDSC,-
			P1=R3,-
			P2=R0
		PUSHAQ	CRCDSC
		CALLS	#1,PRINTIT
		JSB	SHOWRCVD
100$:		BRW	RETRY

NORMAL:
		JSB	SHOWRCVD
95$:		BRW	EXIT

RETRY:
		DECB	RETRYCOUNT		;DECREMENT RETRIES
		BGTR	94$			;
		BRW	EXIT			;IF NO MORE RETRIES, EXIT
94$:
		$SETIMR_S	-
			EFN = #4,-
			DAYTIM = RTIME		;WAIT BETWEEN RETRIES
		$WAITFR_S	EFN = #4

		BRW	SENDSEQ

		

READSETUP:
		CLRQ	IN_IOSB			;RESET IO STATUS


		$CLREF_S	EFN=#READFLAG

		$SETIMR_S	EFN=#TIMEFLAG,-	 ;SET INTERVAL TIMER
				DAYTIM=INT_TIME,-
				REQIDT=#99

		$QIO_S	EFN=#READFLAG,-
			CHAN=G^MH2_ICHAN,-
			FUNC=#IO$_TTYREADALL,-
			IOSB=IN_IOSB,-
			ASTADR=READAST,-
			P1=TEMPBUF,-
			P2=#1

		BLBS	R0,10$

		PUSHL	R0
		$CANCEL_S	CHAN=G^MH2_ICHAN ;CANCEL IO AND TIMER
		$CANTIM_S	REQIDT=#99
		POPL	R0
		RSB

10$:
		RSB

RDINIT:		CLRQ	TRMASK			;
		CLRW	BYTESRCVD		;BYTES RECEIVED = 0.
		CLRB	TEMPBUF			;EMPTY RECEIVE BUFFER.
		CLRB	RDSTAT			;INIT. READ STATUS
		MOVAB	G^MH2_RBUF,OFFSET	;POINT TO START OF INPUT BUFFER
		CLRW	BYTESTOGO
		CLRW	G^MH2_STATUS2		;INIT SECONDARY STATUS RETURN
		RSB


EXIT:
		BICW2	#<NOWSENDING+NOWREADING>,G^MH2_HANDLER_STATUS	
		TSTB	DISPFLAG
		BEQL	98$
		PUSHAQ	BLANKLINE
		CALLS	#1,PRINTIT
98$:
		$SETSWM_S	SWPFLG=#0
		$SETPRI_S	PRI=OLDPRI
		BITB	#WRITEONLY,G^MH2_FLAGS
		BNEQ	99$
		MOVZWL	IN_IOSB,G^MH2_STATUSL	;RETURN ERROR FROM IOSB
99$:		RET

BADLIB:	
		RET


SHOWRCVD:
		TSTB	DISPFLAG		;DO WE WANT TO SHOW MESSAGE?
		BEQL	RCVEXIT
		TSTL	BYTESRCVD
		BNEQ	5$
		PUSHAQ	RCVD
		CALLS	#1,PRINTIT
		BRB	RCVEXIT
5$:
		PUSHL	#RCVDSIZE
		PUSHAB	RCVDSTRING		;PUSH PREFIX ADDRESS
		MOVZWL	BYTESRCVD,R2
		PUSHL	R2			;LENGTH OF RECVD MESSAGE
		MOVAB	G^MH2_RBUF,R2		;ADDRESS OF MESSAGE
		PUSHL	R2			;ADDRESS OF 1ST SYNC TO DISPLAY
		CALLS	#4,HEXOUT		;DUMP HEX MESSAGE TO SCREEN
RCVEXIT:	RSB


.PAGE
;*****************************************************************************
;*									     *
;*		R E A D      A. S. T.    F U N C T I O N		     *
;*									     *
;*	HANDLES THE RECEIPT OF EACH CHARACTER ON QIO READ COMPLETION.	     *
;*									     *
;*****************************************************************************


READAST:
		.WORD	0
		$READEF_S	EFN=#1,-
				STATE=EV_FLAGS	;;;GET EVENT FLAGS

		BITL	#TIMEBIT,EV_FLAGS	;;;TIMEOUT BEFORE CHAR?
		BEQL	CHARCHECK		;;;IF NOT, PROCESS CHARACTER.
		BRW	ASTEXIT

CHARCHECK:
		CMPW	IN_IOSB,#1		;;;DID WE GET A BYTE?
		BEQL	5$			;;;IF SO, PROCESS IT.
		BRW	ASTEXIT			;;;IF NOT, JUST EXIT
5$:
		$CANTIM_S	REQIDT=#99	;;;CANCEL THE TIMER.
		$CLREF_S	EFN=#TIMEFLAG	;;;CLEAR ITS EVENT FLAG.

		BITB	#SYNC2RCVD,RDSTAT	;;;NORMAL MESSAGE MODE?
		BNEQ	ADDBYTE			;;;IF SO, ADD BYTE TO BUFFER.
		CMPB	TEMPBUF,#SYNC		;;;IS THIS A SYNC?
		BNEQ	10$			;;;IF NOT, CONTINUE
		BISB2	#SYNC1RCVD,RDSTAT	;;;IF IT IS,SET SYNC RECEIVED.
		BRW	ASTEXIT			;;;AND EXIT.


10$:
		BITB	#SYNC1RCVD,RDSTAT	;;;HAS SYNC1 BEEN RECEIVED?
		BEQL	15$
		CMPB	TEMPBUF,#SYNC2		;;;IS THIS A SYNC2?
		BNEQ	12$
		BISB2	#SYNC2RCVD,RDSTAT	;;;SET SYNC2 RECEIVED.
12$:
		BICB2	#SYNC1RCVD,RDSTAT	;;;CLEAR SYNC1 RECEIVED.
15$:
		BRW	ASTEXIT


ADDBYTE:
		MOVB	TEMPBUF,@OFFSET		;;;PUT RECEIVED BYTE INTO BUFR.
		INCL	OFFSET			;;;POINT TO NEXT SPOT IN BUFFER
		INCW	BYTESRCVD		;;;INCREMENT BYTE RCV COUNT
		CMPW	BYTESRCVD,#4		;;;IS THIS THE COMMAND BYTE?
		BGTR	50$			;;;IF PAST COMMAND BYTE, SKIPIT
		BEQL	16$			;;;IF COMMAND BYTE, PROCESS IT.
		BRW	ASTEXIT			;;;IF TOO EARLY, EXIT


16$:
		PUSHL	R5			;;;SAVE R5 FOR USE AS SCRATCH
		MOVZBL	TEMPBUF,R5		;;;GET COMMAND/RESPONSE BYTE
		BICB2	#128,R5			;;;CLEAR RESPONSE INDICATOR
		CMPW	R5,LENTBL		;;;IS RESPONSE WITHIN TABLE?
		BGTR	19$			;;;IF NOT, MESSAGE N.G.
		MOVZWL	@#LENTBL[R5],R5		;;;GET LENGTH TABLE ENTRY
		TSTL	R5			;;;EXAMINE IT.
		BEQL	19$			;;;IF 0, SHOULD NOT GET RESP.
		BLSS	20$			;;;IF NEGATIVE, DERIVE SIZE
		MOVW	R5,BYTESTOGO		;;;SAVE NUMBER OF BYTES 
		BRB	25$			;;;


19$:
		BISB2	#GARBRCVD,RDSTAT	;;;SET GARBAGE RECEIVED
		BRB	25$			;;;EXIT
20$:
		BISB2	#GETSIZ,RDSTAT		;;;MUST EXTRACT SIZE FROM MESG
		MOVB	TEMPBUF,OPCODE		;;;SAVE CODE FOR DERIVATION
25$:
		POPL	R5			;;;RESTORE R5
		BRW	ASTEXIT			;;;AND EXIT


50$:
		BITB	#GETSIZ,RDSTAT		;;;MUST WE EXTRACT THE SIZE?
		BEQL	60$			;;;IF NOT, CONTINUE
		CMPW	BYTESRCVD,#6		;;;IS THIS THE BYTE FOR LENGTH?
		BNEQ	60$			;;;IF NOT, CONTINUE
		CMPB	OPCODE,#13		;;;RESP TO SP COMMAND?
		BNEQ	51$			;;;
		MOVZBL	TEMPBUF,R2		;;;GET NUMBER OF EVENTS
		MULB2	#6,R2			;;;6 BYTES PER EVENT
		ADDL	#3,R2			;;;PLUS FLAG AND CRC
		MOVW	R2,BYTESTOGO		;;;SAVE IN TO-GO COUNT
		BRB	53$
51$:
		CMPB	OPCODE,#31		;;;RESP TO QE COMMAND?
		BNEQ	52$
		MOVZBW	TEMPBUF,BYTESTOGO	;;;GET BYTE COUNT
		ADDW	#3,BYTESTOGO		;;;PLUS CRC AND FLAG



53$:
		BICB2	#GETSIZ,RDSTAT		;;;DON'T NEED TO GET SIZE AGAIN
		BRW	ASTEXIT			;;;EXIT

52$:		
		PUSHAQ	BADVARANS		;;;DISPLAY 'BAD MESSAGE'
		CALLS	#1,PRINTIT
		BISB2	#GARBRCVD,RDSTAT	;;;INDICATE GARBAGE RECEIVED
		BRW	ASTEXIT			;;;AND EXIT

60$:
		DECW	BYTESTOGO		;;;DECREMENT BYTES-TO-GO COUNT
		BNEQ	ASTEXIT			;;;END OF MESSAGE?
		BISB	#MSGDONE,RDSTAT		;;;INDICATE IT.
ASTEXIT:
		RET				;;;COMMON RETURN POINT



		.END
